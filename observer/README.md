### 观察者模式

观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，它的所有依赖者（观察者）都会自动收到通知并更新。观察者模式的核心在于主题对象和观察者对象，主题对象负责维护观察者列表并通知观察者，观察者对象负责接收通知并更新自己的状态。观察者模式的优点是将观察者和主题对象解耦，缺点是可能会导致性能问题和循环依赖问题。观察者模式常用于事件驱动的场景，例如GUI界面、消息通知等。


```
+------------------+       +------------------+
|     Subject      |<>---->|    IObserver     |
+------------------+       +------------------+
| -observers: list |       |   +Update()      |
+------------------+       +------------------+

            ^
            |
            |
+-----------------------+
|    ConcreteSubject    |
+-----------------------+
|  +Attach(IObserver)   |
|  +Detach(IObserver)   |
|  +Notify()            |
+-----------------------+

            ^
            |
            |
+-----------------------+
|    ConcreteObserverA  |
+-----------------------+
|   -subject: Subject   |
|   +Update()           |
+-----------------------+
```

在上面的 UML 类图中，Subject 类表示被观察者，它包含一个 IObserver 接口类型的私有变量 observers。IObserver 接口定义了观察者的公共接口，其中包含一个 Update() 方法。具体被观察者类（例如 ConcreteSubject）继承了 Subject 类，并提供了自己的实现。

当被观察者状态发生改变时，它将调用自己的 Notify() 方法来通知所有注册过的观察者对象。每个观察者对象都实现了 IObserver 接口，并提供了自己的更新方法。

在示例中，定义了一个 Subject 结构体和一个 Observer 接口。具体观察者类（例如 ConcreteObserverA 和 ConcreteObserverB）实现了 Update() 方法，并注册到被观察者对象中。

当被观察者状态发生改变时，它将调用自己的 Notify() 方法来通知所有注册过的观察者对象。每个观察者对象都实现了 Update() 方法，并提供了自己的更新方法。

> 观察者模式的优点：
1. 可以实现一对多的依赖关系：观察者模式可以让一个主题对象被多个观察者对象所依赖，当主题对象状态发生变化时，所有依赖它的观察者对象都会自动更新。 
2. 解耦合：观察者模式将主题对象和观察者对象解耦合，使它们之间的关系变得松散，从而提高了系统的灵活性和可扩展性。 
3. 可以随时添加或删除观察者：由于主题对象和观察者对象之间是松散耦合的，所以可以随时添加或删除观察者，而不需要修改主题对象或观察者对象的代码。
> 观察者模式的缺点：
1. 观察者过多时可能会影响系统性能：当观察者过多时，主题对象状态的变化会通知所有观察者对象，可能会影响系统的性能。 
2. 观察者和主题对象之间的关系过于紧密：观察者模式可能会导致观察者和主题对象之间的关系过于紧密，使得系统难以维护和扩展。
