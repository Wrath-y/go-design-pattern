### 装饰器模式

装饰器模式（Decorator Pattern）是一种结构型设计模式，它允许你动态地将行为添加到对象中，而无需通过继承扩展其功能。它是一种在不改变对象自身结构的情况下，通过组合或嵌套方式来增强或拓展对象的功能的设计模式。

在装饰器模式中，有一个抽象组件类，定义了对象的基本功能，然后有一个具体的组件类，实现了基本功能，再有一个抽象装饰器类，实现了对组件对象的包装，并且有一个与抽象组件类一致的接口。具体的装饰器类可以为所装饰的对象添加新的功能，也可以在不改变原有功能的基础上对其进行拓展。装饰器类可以嵌套使用，从而实现对对象功能的不断拓展。

```
+--------------+         +------------------------+
|   Component  |<>-------|      Decorator         |
+--------------+         +------------------------+
|  operation() |         |  -component: Component |
+--------------+         |  +operation(): void    |
                         +------------------------+
                                     △
                                     |
              +----------------------|----------------------+
              |                      |                      |
      +-------------------+ +--------------------+ +--------------------+
      | ConcreteComponent | | ConcreteDecoratorA | | ConcreteDecoratorB |
      +-------------------+ +--------------------+ +--------------------+
      | operation()       | | operation()        | | operation()        |
      +-------------------+ +--------------------+ +--------------------+
```
其中，Component是被装饰对象和装饰器对象的共同接口；ConcreteComponent是具体的被装饰对象，实现Component接口；Decorator是抽象装饰器对象，实现Component接口，并且包含一个指向Component对象的引用；ConcreteDecorator是具体的装饰器对象，继承自Decorator，并且可以增加额外的行为。

> 装饰器模式的优点包括：
1. 可以动态地给对象添加功能，而不影响其他对象。
2. 可以用多个装饰器包装一个对象，使功能更加灵活。 
3. 通过使用不同的具体装饰器类，可以实现不同的组合效果，拓展对象功能的同时不影响原有的功能。
> 装饰器模式的缺点包括：
1. 对象需要维护大量的装饰器类，使得程序变得复杂。
2. 装饰器模式与原有对象的继承关系可能会变得困难。
